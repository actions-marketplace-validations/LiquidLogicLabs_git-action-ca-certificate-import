# GitHub/Gitea Action Best Practices

This document outlines best practices for creating GitHub/Gitea Actions based on patterns used in LiquidLogicLabs action repositories.

## Project Structure

### Required Files

- `action.yml` - Action metadata, inputs, outputs, and runtime configuration
- `package.json` - Node.js dependencies and build scripts
- `tsconfig.json` - TypeScript configuration
- `CHANGELOG.md` - Keep a Changelog format (optional - only if you want to maintain a changelog file)
- `README.md` - Comprehensive documentation with badges and examples
- `.gitignore` - Organized by category (dependencies, build outputs, IDE, OS files, etc.)

### Directory Structure

```txt
action-name/
â”œâ”€â”€ action.yml              # Action definition
â”œâ”€â”€ package.json            # Dependencies and scripts
â”œâ”€â”€ tsconfig.json           # TypeScript config
â”œâ”€â”€ CHANGELOG.md            # Keep a Changelog format
â”œâ”€â”€ README.md               # Documentation with badges
â”œâ”€â”€ .gitignore              # Organized ignore patterns
â”œâ”€â”€ src/                    # TypeScript source code
â”‚   â”œâ”€â”€ index.ts           # Main entry point
â”‚   â”œâ”€â”€ types.ts           # TypeScript type definitions
â”‚   â””â”€â”€ [module].ts        # Modular code organization
â”œâ”€â”€ dist/                   # Built output (COMMITTED to git)
â”‚   â””â”€â”€ index.js           # Bundled action code
â”œâ”€â”€ .github/
â”‚   â””â”€â”€ workflows/
â”‚       â”œâ”€â”€ ci.yml         # CI workflow (calls test.yml)
â”‚       â”œâ”€â”€ test.yml       # Reusable test workflow
â”‚       â””â”€â”€ release.yml     # Release workflow (validation, package, release)
â””â”€â”€ scripts/                # Optional helper scripts
    â””â”€â”€ [helper].js        # Release/build helpers
```

## Action Definition (action.yml)

### Structure

**For Node.js Actions:**

```yaml
name: 'Action Name'
description: 'Clear, concise description of what the action does'
author: 'Optional author name'
inputs:
  input_name:
    description: 'Clear description with examples if needed'
    required: false
    default: 'default-value'
outputs:
  output_name:
    description: 'Clear description of output value'
runs:
  using: 'node20'  # Always use Node.js 20
  main: 'dist/index.js'  # Point to bundled output
branding:
  icon: 'icon-name'  # Choose appropriate icon
  color: 'blue'     # Choose appropriate color
```

**For Composite Actions (shell-based):**

```yaml
name: 'Action Name'
description: 'Clear, concise description of what the action does'
author: 'Optional author name'
inputs:
  input_name:
    description: 'Clear description with examples if needed'
    required: false
    default: 'default-value'
outputs:
  output_name:
    description: 'Clear description of output value'
runs:
  using: 'composite'
  steps:
    - name: Step name
      shell: bash  # or powershell, pwsh, python, etc.
      run: ${{ github.action_path }}/script.sh
      env:
        INPUT_VAR: ${{ inputs.input_name }}
branding:
  icon: 'icon-name'  # Choose appropriate icon
  color: 'blue'     # Choose appropriate color
```

### Best Practices

- Use descriptive input/output names (snake_case)
- Provide clear descriptions with examples for complex inputs
- Set sensible defaults for optional inputs
- **For Node.js actions:**
  - Always use `node20` as the runtime
  - Point `main` to `dist/index.js` (the bundled output)
- **For composite actions:**
  - Use `using: 'composite'`
  - Reference scripts using `${{ github.action_path }}/script.sh`
  - Set environment variables from inputs for shell scripts
- Include branding for better GitHub Marketplace appearance

## TypeScript Configuration

### tsconfig.json Pattern

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "commonjs",
    "lib": ["ES2022"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "moduleResolution": "node",
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "**/*.test.ts", "dist", "lib", "**/__tests__/**"]
}
```

### Key Points

- Target ES2022 for modern Node.js 20
- Use CommonJS modules (required for GitHub Actions)
- Enable strict mode for type safety
- Generate source maps for debugging
- Exclude test files from compilation

## Package.json Configuration

### Required Scripts

```json
{
  "scripts": {
    "build": "tsc && ncc build src/index.ts -o dist --source-map --license licenses.txt",
    "package": "npm run build",
    "test": "jest",
    "lint": "eslint src/**/*.ts",
    "format": "prettier --write \"src/**/*.ts\""
  }
}
```

### Dependencies

- **Runtime**: Only `@actions/core` (no other runtime deps unless absolutely necessary)
- **Dev Dependencies**: TypeScript, ESLint, Prettier, Jest, @vercel/ncc, @types packages

### Build Process

1. Compile TypeScript: `tsc`
2. Bundle with ncc: `ncc build src/index.ts -o dist --source-map --license licenses.txt`
3. Output to `dist/index.js` (single bundled file)

## Source Code Organization

### Main Entry Point (src/index.ts)

```typescript
import * as core from '@actions/core';
import { helperFunction } from './helper';

async function run(): Promise<void> {
  try {
    // Get inputs
    const input = core.getInput('input_name');
    
    // Validate inputs
    if (!input) {
      throw new Error('Input is required');
    }
    
    // Core logic
    const result = await helperFunction(input);
    
    // Set outputs
    core.setOutput('output_name', result);
    
    core.info('Action completed successfully');
  } catch (error) {
    if (error instanceof Error) {
      core.setFailed(error.message);
    } else {
      core.setFailed('Unknown error occurred');
    }
  }
}

// Run the action
run();
```

### Code Organization Principles

- **Modular design**: Split functionality into separate modules/files
- **Type safety**: Define types in `types.ts` or per-module
- **Error handling**: Always wrap in try/catch, use `core.setFailed()`
- **Logging**: Use `core.info()`, `core.warning()`, `core.error()` appropriately
- **Secret masking**: Use `core.setSecret()` for sensitive values
- **Input validation**: Validate inputs early and provide clear error messages

## CI/CD Workflows

### Workflow Organization Pattern

**Recommended Pattern**: Use a reusable `test.yml` workflow that can be called by both `ci.yml` and `release.yml`. This keeps test logic in one place and avoids duplication.

```txt
ci.yml (entry point) â†’ test.yml (reusable workflow)
release.yml (entry point) â†’ test.yml (reusable workflow)
```

### CI Workflow (.github/workflows/ci.yml)

**Simple Pattern** (recommended for most actions):

```yaml
name: CI

on:
  push:
    branches: ['**']
  pull_request:
    branches: ['**']

permissions:
  contents: read
  pull-requests: read

jobs:
  test:
    uses: ./.github/workflows/test.yml
```

**Full Pattern** (if you need inline steps for Node.js actions):

```yaml
name: CI

on:
  push:
    branches: ['**']
  pull_request:
    branches: ['**']

jobs:
  lint-and-test:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run linter
        run: npm run lint

      - name: Type check
        run: npx tsc --noEmit

      - name: Build
        run: npm run build

      - name: Run tests
        run: npm test
        continue-on-error: true  # Don't fail CI if tests are missing

      # Optional: Add integration tests for your action
      # Example: Test the action with various inputs
      - name: Test action with different scenarios
        run: |
          node dist/index.js || true
        env:
          INPUT_PATH: ./CHANGELOG.md
          INPUT_VERSION: Unreleased
        continue-on-error: true
```

### Reusable Test Workflow (.github/workflows/test.yml)

Create a reusable test workflow that can be called by both CI and release workflows:

```yaml
name: Test

on:
  workflow_call:  # Only workflow_call - no direct triggers

permissions:
  contents: read

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Add your test steps here
      # For Node.js actions: setup Node.js, install deps, run tests
      # For composite actions: test the action directly with various inputs
      - name: Run tests
        run: npm test
```

**Benefits:**

- Single source of truth for test logic
- Can be called by both CI and release workflows
- Easier to maintain and update

### Release Workflow (.github/workflows/release.yml)

```yaml
name: Release

on:
  push:
    tags:
      - 'v*.*.*'  # Semver tags only

permissions:
  contents: write
  pull-requests: read

jobs:
  test:
    uses: ./.github/workflows/test.yml

  release:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for changelog generation

      - name: Check version format in tag
        id: version
        uses: nowsprinting/check-version-format-action@v4
        with:
          prefix: 'v'

      # Build validation (for Node.js actions)
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build and package action
        run: npm run package

      # Build validation (for composite actions)
      # Validate action.yml and any shell scripts exist and are valid
      - name: Build validation
        run: |
          echo "ðŸ”¨ Validating action before release..."
          
          # Validate action.yml
          if [ -f "action.yml" ]; then
            echo "âœ“ action.yml found"
          else
            echo "âœ— action.yml not found"
            exit 1
          fi
          
          # Validate scripts (if composite action)
          if [ -f "install-script.sh" ]; then
            bash -n install-script.sh  # Syntax check
            echo "âœ“ install-script.sh syntax valid"
          fi

      - name: Generate release notes
        id: release_notes
        uses: mikepenz/release-changelog-builder-action@v6
        with:
          configurationJson: |
            {
              "template": "#{{CHANGELOG}}\n\n<details>\n<summary>Pull Requests</summary>\n\n#{{PR_LIST}}\n</details>"
            }
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create GitHub Release
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ github.ref_name }}
          name: Release ${{ steps.version.outputs.full_without_prefix }}
          body: ${{ steps.release_notes.outputs.changelog }}
          draft: false
          prerelease: ${{ steps.version.outputs.is_stable != 'true' }}
          token: ${{ secrets.GITHUB_TOKEN }}
```

**Key Points:**

- Always run tests before release (via reusable `test.yml`)
- Validate action files and scripts before releasing
- For Node.js actions: build and package before release
- For composite actions: validate `action.yml` and shell script syntax

## Git Configuration

### .gitignore Organization

```gitignore
# Dependencies
node_modules/

# Build outputs
lib/
*.tsbuildinfo

# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*

# Environment variables
.env
.env.local

# IDE and editor files
.idea/
*.swp
*.swo
*~

# OS files
.DS_Store

# Test coverage
coverage/
.nyc_output/

# AI Tools
.bmad-core/
.github/chatmodes/
```

### Important Notes

- **DO commit `dist/` folder** - It's required for the action to work
- **DO NOT commit** `node_modules/`, `lib/`, or build artifacts
- Organize `.gitignore` by category with comments

## Documentation (README.md)

### Required Sections

1. **Badges** - CI status, License, TypeScript version
2. **Description** - What the action does
3. **Features** - Bullet list of key capabilities
4. **Usage Examples** - Multiple real-world examples
5. **Inputs Table** - All inputs with descriptions
6. **Outputs Table** - All outputs with descriptions
7. **Configuration** - If config files are supported
8. **Examples** - Complete workflow examples
9. **Security** - Security considerations
10. **License** - MIT (typically)
11. **Credits/Acknowledgments** - If based on another project

### Badge Examples

```markdown
[![CI](https://github.com/org/repo/actions/workflows/ci.yml/badge.svg)](https://github.com/org/repo/actions/workflows/ci.yml)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![TypeScript](https://img.shields.io/badge/TypeScript-5.3-blue.svg)](https://www.typescriptlang.org/)
```

## CHANGELOG.md

### Format (Keep a Changelog)

```markdown
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

## [1.0.0] - 2025-12-23

### Added
- Initial implementation
- Feature descriptions

### Changed
- Change descriptions

### Fixed
- Bug fix descriptions
```

## Code Quality

### Linting

- Use ESLint with TypeScript rules
- Configure in `.eslintrc.json`
- Run `npm run lint` in CI

### Formatting

- Use Prettier for consistent formatting
- Configure in `.prettierrc.json`
- Format before committing

### Testing

- Write unit tests for core functionality
- Use Jest with ts-jest
- Place tests in `src/__tests__/` or alongside source files
- Use `continue-on-error: true` in CI if tests are optional

## Security Best Practices

1. **Token Handling**
   - Use `core.setSecret()` to mask tokens in logs
   - Only use tokens when necessary
   - Prefer environment variables over hardcoded values

2. **Input Validation**
   - Validate all inputs
   - Sanitize user-provided data
   - Provide clear error messages

3. **Dependencies**
   - Minimize runtime dependencies
   - Keep dependencies up to date
   - Review security advisories

4. **No API Dependencies**
   - Prefer standard HTTP over platform-specific APIs when possible
   - Makes actions more portable and platform-agnostic

## Release Process

1. **Commit changes** to main branch (optionally update CHANGELOG.md if you maintain one)
2. **Create semver tag**: `git tag v1.2.3`
3. **Push tag**: `git push origin v1.2.3`
4. **Release workflow** automatically:
   - Validates version format using `check-version-format-action`
   - Builds and packages the action
   - Generates release notes from PRs/commits using `release-changelog-builder-action`
   - Creates GitHub release with generated notes
   - Detects prerelease status automatically
5. **Action is available** at `@v1.2.3`

### Version Format Validation

Use `nowsprinting/check-version-format-action@v4` to:

- Validate semver format in tags
- Extract version components (major, minor, patch, prerelease)
- Determine if version is stable (for prerelease detection)
- Get version with or without prefix

### Release Notes Generation

Use `mikepenz/release-changelog-builder-action@v6` to:

- Generate changelog from merged PRs between tags
- Customize format with templates
- Include PR lists and contributor information
- Configure categories and exclusions via `configurationJson`

## Examples from LiquidLogicLabs Actions

### changelog-parser-action

- Extends functionality of existing action (changelog-reader-action)
- Adds remote URL support with blob-to-raw conversion
- Supports repository root URL detection and automatic CHANGELOG.md fetching
- Comprehensive URL handling for multiple platforms (GitHub, GitLab, Bitbucket, Gitea)
- Uses `check-version-format-action` for version validation
- Uses `release-changelog-builder-action` for automated release notes generation

### gitea-action-trigger-workflow

- Gitea-specific action (not GitHub)
- Modular code organization (config, http, gitea, log modules)
- Comprehensive error handling and logging
- Uses conventional-changelog-cli for changelog generation
- Includes floating tag support (v1, v1.2)

## Key Principles

1. **Simplicity**: Keep actions focused on a single purpose
2. **Portability**: Avoid platform-specific APIs when possible
3. **Documentation**: Comprehensive README with examples
4. **Type Safety**: Use TypeScript with strict mode (for Node.js actions)
5. **Error Handling**: Always handle errors gracefully
6. **Testing**: Test when possible inside a runner (ex: act)
7. **CI/CD**: Automate build, test, and release processes
   - Use reusable workflows (`test.yml`) to avoid duplication
   - Keep CI simple (entry point that calls reusable workflows)
   - Validate before releasing (tests + build validation)
8. **Attribution**: Credit original authors when extending existing work
